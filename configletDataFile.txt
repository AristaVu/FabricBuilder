{"data":{"configlet":[],"configletBuilder":[{"isAssigned":false,"sslConfig":false,"editable":true,"name":"Fabric builder v5.1","formList":[{"fieldId":"dcname","fieldLabel":"Datacenter name","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"A prefix for your top container and spine\/leaf container","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":0,"key":"fieldId_347_59825640124327","dataValidationErrorExist":false,"previewValue":"Z_cvplab"},{"fieldId":"spines","fieldLabel":"Number of spines","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"[0-9+]","helpText":"Number of spines in datacenter","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":1,"key":"fieldId_348_59825640125095","dataValidationErrorExist":false,"previewValue":"1"},{"fieldId":"spine_start_asn","fieldLabel":"AS number for spines","type":"Text box","value":"65000","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"The AS number to use for spine. Leaf\/Leaf pairs AS number will be calculated with spine AS number as base","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":2,"key":"fieldId_351_59825640127504","dataValidationErrorExist":false,"previewValue":"65000"},{"fieldId":"leafs","fieldLabel":"Number of leafs","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"[0-9]+","helpText":"Number of leafs in the datacenter","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":3,"key":"fieldId_338_59825640117018","dataValidationErrorExist":false,"previewValue":"4"},{"fieldId":"max_routes","fieldLabel":"Max routes in the underlay","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"[0-9]+","helpText":"Max routes in the underlay","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":4,"key":"fieldId_349_59825640125893","dataValidationErrorExist":false,"previewValue":"12000"},{"fieldId":"defaultgw","fieldLabel":"Default gateway for OOB Mgmt network","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Default gateway for OOB Mgmt network","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":5,"key":"fieldId_333_59825640111281","dataValidationErrorExist":false,"previewValue":"10.251.0.1"},{"fieldId":"mgmtnet","fieldLabel":"Mgmt network prefix","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Mgmt network prefix without last octet, example 192.0.0.","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":6,"key":"fieldId_342_59825640120309","dataValidationErrorExist":false,"previewValue":"10.251.0."},{"fieldId":"mgmtvrf","fieldLabel":"Mgmt VRF","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Name of the management vrf, example \"MGMT\"","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":7,"key":"field_26_1597787529399","dataValidationErrorExist":false,"previewValue":"MGMT"},{"fieldId":"mgmtnetmask","fieldLabel":"Mgmt network netmask","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Mgmt network netmask, example \"24\"","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":8,"key":"fieldId_355_59825640130538","dataValidationErrorExist":false,"previewValue":"24"},{"fieldId":"vxlanloopback","fieldLabel":"VXLAN loopback address prefix","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"VXLAN loopback address prefix without last octet, example 192.0.0.","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":9,"key":"fieldId_353_59825640129003","dataValidationErrorExist":false,"previewValue":"10.0.2."},{"fieldId":"loopback","fieldLabel":"Loopback address prefix","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Loopback address prefix without last octet, example 192.0.0.","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":10,"key":"fieldId_337_59825640116232","dataValidationErrorExist":false,"previewValue":"10.0.1."},{"fieldId":"linknetwork","fieldLabel":"Fabric link network prefix","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Fabric link network prefix without last octet, example 192.0.0.","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":11,"key":"fieldId_332_59825640110112","dataValidationErrorExist":false,"previewValue":"10.0.0."},{"fieldId":"virtual","fieldLabel":"Is deployment vEOS or physical devices?","type":"Radio button","value":"virtual,physical","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Whether deployment FabricBuilder is building is for vEOS or physical devices","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":12,"key":"fieldId_341_59825640119480","dataValidationErrorExist":false,"previewValue":"virtual"},{"fieldId":"uplinks","fieldLabel":"Number of uplinks per leaf","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"How many uplinks does each leaf have to spine layer","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":13,"key":"fieldId_339_59825640117805","dataValidationErrorExist":false,"previewValue":"1"},{"fieldId":"mlag","fieldLabel":"MLAG","type":"Radio button","value":"yes,no","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Should leafs be organized into MLAG pairs?","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":14,"key":"fieldId_336_59825640115396","dataValidationErrorExist":false,"previewValue":"yes"},{"fieldId":"mlagnetwork","fieldLabel":"MLAG peer network","type":"Text box","value":"","depends":"mlag:yes","validation":{"mandatory":false},"dataValidation":"","helpText":"Network prefix including trailing dot \".\" for MLAG peernetwork, example 10.0.0.","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":15,"key":"fieldId_354_59825640129798","dataValidationErrorExist":false,"previewValue":"192.168.255."},{"fieldId":"mlagtrunkinterfaces","fieldLabel":"MLAG trunk interfaces","type":"Text box","value":"","depends":"mlag:yes","validation":{"mandatory":false},"dataValidation":"","helpText":"Interfaces to use for MLAG trunk between leafs, example Ethernet1,Ethernet2","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":16,"key":"fieldId_340_59825640118649","dataValidationErrorExist":false,"previewValue":"Ethernet7,Ethernet8"},{"fieldId":"deploymenttype","fieldLabel":"Deployment type","type":"Radio button","value":"her,cvx,evpn","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Deployment type, i.e. HER, CVX or evpn","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":17,"key":"fieldId_345_59825640122762","dataValidationErrorExist":false,"previewValue":"evpn"},{"fieldId":"cvx_server","fieldLabel":"CVX Server","type":"Text box","value":"","depends":"deploymenttype:cvx","validation":{"mandatory":false},"dataValidation":"","helpText":"IP address to CVX server","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":18,"key":"fieldId_335_59825640113095","dataValidationErrorExist":false,"previewValue":""},{"fieldId":"max_evpn_routes","fieldLabel":"Max routes in EVPN","type":"Text box","value":"12000","depends":"deploymenttype:evpn","validation":{"mandatory":true},"dataValidation":"[0-9]+","helpText":"Max routes of all types to be announced in EVPN","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":19,"key":"fieldId_346_59825640123558","dataValidationErrorExist":false,"previewValue":"12000"},{"fieldId":"snmp_public","fieldLabel":"Public SNMP community","type":"Text box","value":"public","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"The SNMP community string to use for read only access.","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":20,"key":"fieldId_331_59825640104409","dataValidationErrorExist":false,"previewValue":"public"},{"fieldId":"snmp_private","fieldLabel":"Private SNMP community","type":"Text box","value":"private","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"The SNMP community string to use for read write access.","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":21,"key":"fieldId_343_59825640121102","dataValidationErrorExist":false,"previewValue":"private"},{"fieldId":"syslogserver","fieldLabel":"IP of syslog server","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"IP address of syslog server to use","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":22,"key":"fieldId_344_59825640121924","dataValidationErrorExist":false,"previewValue":"10.251.0.1"},{"fieldId":"log_facility","fieldLabel":"Log facility to use with syslog","type":"Drop down","value":"local0,local1,local2,local3,local4,local5,local6,local7","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"Log facility to use on remote syslog server","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":23,"key":"fieldId_350_59825640126699","dataValidationErrorExist":false,"previewValue":"local3"},{"fieldId":"primary_ntp","fieldLabel":"Primary NTP server","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"IP address of primary NTP server to use","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":24,"key":"fieldId_352_59825640128264","dataValidationErrorExist":false,"previewValue":"10.251.0.1"},{"fieldId":"second_ntp","fieldLabel":"Secondary NTP","type":"Text box","value":"","depends":"","validation":{"mandatory":true},"dataValidation":"","helpText":"IP address of secondary NTP server to use","configletBuilderId":"configletBuilderMapper_15_955190426017","orderId":25,"key":"fieldId_334_59825640112235","dataValidationErrorExist":false,"previewValue":"10.251.0.2"}],"type":"BUILDER_WITHOUT_DRAFT","main_script":{"data":"import cvp\nfrom string import Template\nfrom cvplibrary import CVPGlobalVariables,GlobalVariableNames\nfrom cvplibrary import Form\n\n#\n# Assign constants\n#\n\n#host = CVPGlobalVariables.getValue(GlobalVariableNames.CVP_IP)\nhost = '10.251.0.19'\nuser = CVPGlobalVariables.getValue(GlobalVariableNames.CVP_USERNAME)\npassword = CVPGlobalVariables.getValue(GlobalVariableNames.CVP_PASSWORD)\nparentName = 'Tenant'\n\n#\n# Assign command line options to variables and assign static variables\n#\n\nname = Form.getFieldById('dcname').getValue()\nno_spine = int(Form.getFieldById('spines').getValue())\nno_leaf = int(Form.getFieldById('leafs').getValue())\ndefaultgw = Form.getFieldById('defaultgw').getValue()\nmgmtnetwork = Form.getFieldById('mgmtnet').getValue()\nmgmtvrf = Form.getFieldById('mgmtvrf').getValue()\nmgmtnetmask = int(Form.getFieldById('mgmtnetmask').getValue())\nvxlanloopback = Form.getFieldById('vxlanloopback').getValue()\nloopback = Form.getFieldById('loopback').getValue()\nlinknetwork = Form.getFieldById('linknetwork').getValue()\ndeploymenttype = Form.getFieldById('deploymenttype').getValue()\ncvxserver = Form.getFieldById('cvx_server').getValue()\n\nmlag = Form.getFieldById('mlag').getValue()\nif mlag == \"yes\":\n  mlagnetwork = Form.getFieldById('mlagnetwork').getValue()\n  mlagtrunkinterfaces = Form.getFieldById('mlagtrunkinterfaces').getValue()\n\nvirtual = Form.getFieldById('virtual').getValue()\nuplinks = Form.getFieldById('uplinks').getValue()\nsnmp_public = Form.getFieldById('snmp_public').getValue()\nsnmp_private = Form.getFieldById('snmp_private').getValue()\nsyslogserver = Form.getFieldById('syslogserver').getValue()\nlog_facility = Form.getFieldById('log_facility').getValue()\nprimary_ntp = Form.getFieldById('primary_ntp').getValue()\nsecond_ntp = Form.getFieldById('second_ntp').getValue()\nspine_start_asn = Form.getFieldById('spine_start_asn').getValue()\nmax_routes = Form.getFieldById('max_routes').getValue()\nmax_evpn_routes = Form.getFieldById('max_evpn_routes').getValue()\nmax_ecmp = int(uplinks) * int(no_spine)\n\nmy_spine_container_name = name + \" Spine\"\nmy_leaf_container_name = name + \" Leaf\"\ndc_configlet_name = name + \" Base config\"\nconfiglet_list = []\ncvx_configlet_list = []\nleaf_configlet_list = []\n\n#\n# Support functions for main code\n#\n\ndef configletExists( cvpServer , configlet_name ):\n\tconfiglet_exist = 0\n\tmyConfiglets = cvpServer.getConfiglets()\n\tfor myConfiglet in myConfiglets:\n\t\tif myConfiglet.name == configlet_name:\n\t\t\tconfiglet_exist = 1\n\treturn configlet_exist\n\ndef updateMyConfiglet( cvpServer , configlet_name , configlet_config ):\n\tmyConfiglet = cvpServer.getConfiglet( configlet_name )\n\tmyConfiglet.config = configlet_config\n\tcvpServer.updateConfiglet( myConfiglet )\n\ndef containerExists( cvpServer , container_name ):\n\tcontainer_exist = 0\n\tmyContainers = cvpServer.getContainers()\n\tfor myContainer in myContainers:\n\t\tif myContainer.name == container_name:\n\t\t\tcontainer_exist = 1\n\treturn container_exist\n\n#\n#\n# The first part of the code builds a dictionary representing first all the spines\n# and their relevant data to create their config.\n#\n# Second part of the code builds a dictionary representing first all the leafs\n# and their relevant data to create their config.\n#\n\n#\n# Build the DC list of spine switches in dictionary form.\n#\n\nlinksubnetcounter = 0\nloopbackcounter = 0\nvxlanloopbackcounter = 0\nmgmtnetworkcounter = 80\n\nDC = []\nLeafs = []\n\nfor counter in range(1,no_spine+1):\n\tspine_name = name + \"spine\" + str(counter)\n\tinterface_list = []\n\telement_dict = {}\n\telement_dict['name'] = spine_name\n\telement_dict['loopback'] = loopback + str(loopbackcounter)\n\tloopbackcounter = loopbackcounter + 1\n\telement_dict['mgmt'] = mgmtnetwork + str(mgmtnetworkcounter)\n\tmgmtnetworkcounter = mgmtnetworkcounter + 1\n\tcounter3 = 1\n\n\tfor counter2 in range(1,int(no_leaf)+1):\n\t\tfor i in range(1,int(uplinks)+1):\n\t\t\tif virtual == \"physical\":\n\t\t\t\tspine_interface_name = \"Ethernet\"+str(counter3)+\"\/1\"\n\t\t\telse:\n\t\t\t\tspine_interface_name = \"Ethernet\"+str(counter3)\n\n\t\t\tleaf_name = name + \"leaf\" + str(counter2)\n\t\t\tneighbor_dict = {}\n\t\t\tneighbor_dict['neighbor'] = leaf_name\n\t\t\tlink = linknetwork + str(linksubnetcounter)\n\t\t\tneighborlink = linknetwork + str(linksubnetcounter+1)\n\t\t\tneighborint = str(linksubnetcounter+1)\n\t\t\tlinksubnetcounter = linksubnetcounter + 2\n\t\t\tneighbor_dict['linknet'] = link\n\t\t\tneighbor_dict['neighbor_ip'] = neighborlink\n\t\t\tif virtual == \"physical\":\n\t\t\t\tneighbor_dict['neighbor_interface'] = \"Ethernet\" + str(i + 48 + ((counter - 1) * int(uplinks))) + \"\/1\"\n\t\t\telse:\n\t\t\t\tneighbor_dict['neighbor_interface'] = \"Ethernet\" + str(i + ((counter - 1) * int(uplinks)))\n\t\t\t\n\t\t\tneighbor_dict['local_interface'] = spine_interface_name\n\t\t\tneighbor_dict['neighbor_int'] = neighborint\n\t\t\t\n\t\t\tneighbor_asn = int(spine_start_asn) + counter2\n\t\t\tif neighbor_asn % 2 == 1:\n\t\t\t\tneighbor_dict['asn'] = neighbor_asn\n\t\t\telse:\n\t\t\t\tneighbor_dict['asn'] = neighbor_asn - 1 \n\t\t\t\n\t\t\tinterface_list.append(neighbor_dict)\n\t\t\tcounter3 = counter3 + 1\n\t\t\n\t\telement_dict['interfaces'] = interface_list\n\t\n\tDC.append(element_dict)\n\n#\n# Build the Leaf list of leaf switches in dictionary form.\n#\n\n#\n# If leafs are organised as MLAG pairs, build accordingly.\n#\n\nif mlag == \"yes\":\n\tfor counter in range (1,no_leaf+1):\n\t\tleaf_dict = {}\n\t\tleaf_dict['name'] = name + \"leaf\" + str(counter)\n\t\tleaf_dict['loopback'] = loopback + str(loopbackcounter)\n\t\tloopbackcounter = loopbackcounter +1\n\t\tif vxlanloopbackcounter % 2 == 1:\n\t\t\tmlaginterface = mlagnetwork + \"0\"\n\t\t\tmlagpeer = mlagnetwork + \"1\"\n\t\t\tleaf_dict['mlaginterface'] = mlaginterface\n\t\t\tleaf_dict['mlagpeer'] = mlagpeer\n\t\t\tleaf_dict['vxlan'] = vxlanloopback + str(vxlanloopbackcounter - 1)\n\t\telse:\n\t\t\tmlaginterface = mlagnetwork + \"1\"\n\t\t\tmlagpeer = mlagnetwork + \"0\"\n\t\t\tleaf_dict['mlaginterface'] = mlaginterface\n\t\t\tleaf_dict['mlagpeer'] = mlagpeer\n\t\t\tleaf_dict['vxlan'] = vxlanloopback + str(vxlanloopbackcounter)\n\t\tvxlanloopbackcounter = vxlanloopbackcounter +1\n\t\tleaf_dict['mgmt'] = mgmtnetwork + str(mgmtnetworkcounter)\n\t\tmgmtnetworkcounter = mgmtnetworkcounter + 1\n\t\tasn = int(spine_start_asn) + counter\n\t\tif asn % 2 == 1:\n\t\t\tleaf_dict['asn'] = asn\n\t\telse:\n\t\t\tleaf_dict['asn'] = asn - 1 \n\n\t\tLeafs.append(leaf_dict)\n\n#\n# If leafs are organised standalone, build accordingly.\n#\n\nif mlag == \"no\":\n\tfor counter in range (1,no_leaf+1):\n\t\tleaf_dict= {}\n\t\tleaf_dict['name'] = name + \"leaf\" + str(counter)\n\t\tleaf_dict['loopback'] = loopback + str(loopbackcounter)\n\t\tloopbackcounter = loopbackcounter +1\n\t\tleaf_dict['vxlan'] = vxlanloopback + str(vxlanloopbackcounter)\n\t\tvxlanloopbackcounter = vxlanloopbackcounter +1\n\t\tleaf_dict['mgmt'] = mgmtnetwork + str(mgmtnetworkcounter)\n\t\tmgmtnetworkcounter = mgmtnetworkcounter + 1\n\t\tasn = int(spine_start_asn) + counter\n\t\tleaf_dict['asn'] = asn\n\n\t\tLeafs.append(leaf_dict)\n\n#\n# Build a VTEP list for the HER use case.\n#\n\nif deploymenttype == \"her\":\n\tvteplist = \"\"\n\tfor leaf in Leafs:\n\t\tif leaf['vxlan'] not in vteplist:\n\t\t\tvteplist = vteplist + \" \" + leaf['vxlan']\n\n#\n# Connect and authenticate with CVP server\n#\n\nserver = cvp.Cvp( host )\nserver.authenticate( user , password )\n\n#\n# Create needed configlets for the new DC\n#\n\nReplacements = {\n                \"defaultgw\": defaultgw,\n                \"syslog\": syslogserver,\n                \"private\": snmp_private,\n                \"public\": snmp_public,\n                \"facility\": log_facility,\n                \"primary_ntp\": primary_ntp,\n                \"second_ntp\": second_ntp,\n                \"mgmtvrf\": mgmtvrf \n                }\n\ndc_base_config = Template(\"\"\"\n!\ntransceiver qsfp default-mode 4x10G\n!\nlogging buffered 128000\nlogging console informational\nlogging format timestamp high-resolution\nlogging facility $facility\nlogging host $syslog\nlogging source-interface Management1\n!\nsnmp-server community $private rw\nsnmp-server community $public ro\n!\nntp server $primary_ntp prefer version 4\nntp server $second_ntp version 4\n!\nspanning-tree mode mstp\n!\nno aaa root\n!\nip virtual-router mac-address 00:11:22:33:44:55\n!\nvrf instance $mgmtvrf\n!\nip route vrf $mgmtvrf 0.0.0.0\/0 $defaultgw\nip routing\n!\nmanagement api http-commands\n   protocol http\n   cors allowed-origin all\n   no shutdown\n   vrf $mgmtvrf\n   no shutdown\n\"\"\").safe_substitute(Replacements)\n\nif deploymenttype == \"evpn\":\n\tReplacements = {\n    \t\t\t\t\"dummy\":\"dummy\"\n                }\n\n\tarbgp_config = Template(\"\"\"\n!\nservice routing protocols model multi-agent \n!\n\"\"\").safe_substitute(Replacements)\n\tdc_base_config = dc_base_config + arbgp_config\n\n#\n# If debug is activated, only print config that should have gone into configlets,\n# do not actually create configlets. If debug is not activated, create configlets\n# and add them to CVP.\n#\n\ndc_configlet = cvp.Configlet( dc_configlet_name , dc_base_config  )\nif configletExists( server , dc_configlet_name ):\n\tupdateMyConfiglet( server , dc_configlet_name , dc_base_config )\n\trebuild = 1\nelse:\n\tserver.addConfiglet( dc_configlet )\n\tconfiglet_list.append( dc_configlet )\n\trebuild = 0\n  \n#\n# Build base config configlets for spines and add them to CVP.\n# Start with config that is the same in all deployment types.\n#\n\nfor spine_switch in DC:\n\tReplacements = {\n\t\t\t\t\t\"hostname\": spine_switch['name'],\n\t\t\t\t\t\"loopaddress\": spine_switch['loopback'],\n\t\t\t\t\t\"mgmtaddress\": spine_switch['mgmt'],\n\t\t\t\t\t\"mgmtnetmask\": mgmtnetmask,\n\t\t\t\t\t\"mgmtvrf\": mgmtvrf\n\t\t\t\t\t}\n\n\tspine_base_config = Template(\"\"\"\n!\nhostname $hostname\n!\ninterface Loopback0\n   ip address $loopaddress\/32\n!\ninterface Management1\n   vrf $mgmtvrf\n   ip address $mgmtaddress\/$mgmtnetmask\n\"\"\").safe_substitute(Replacements)\n\t\n\tfor interface in spine_switch['interfaces']:\n\t\tReplacements = {\n\t\t\t\t\t\t\"local_interface\": interface['local_interface'] ,\n\t\t\t\t\t\t\"description\": interface['neighbor'],\n\t\t\t\t\t\t\"linknet\": interface['linknet']\n\t\t\t\t\t\t}\n\t\tadd_to_spine_config = Template(\"\"\"\n!\ninterface $local_interface\n   description $description\n   no switchport\n   ip address $linknet\/31\n!\"\"\").safe_substitute(Replacements)\n\n\t\tspine_base_config = spine_base_config + add_to_spine_config\n\n\tspine_configlet_name = spine_switch['name'] + \" configuration\"\n\tif rebuild == 1:\n\t  \t\tupdateMyConfiglet( server , spine_configlet_name , spine_base_config )\n\telse:\n\t\tspine_configlet = cvp.Configlet( spine_configlet_name , spine_base_config )\n\t\tserver.addConfiglet( spine_configlet )\n\t\t\n#\n# Create configlets unique for spine in cvx and her deployment types\n# and add them to CVP.\n#\n\n\tif deploymenttype == \"her\" or deploymenttype == \"cvx\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"routerid\": spine_switch['loopback'],\n\t\t\t\t\t\t\"linknet\": linknetwork + \"0\/24\",\n\t\t\t\t\t\t\"uplinks\": uplinks,\n\t\t\t\t\t\t\"asn\": spine_start_asn,\n\t\t\t\t\t\t\"max_routes\": max_routes,\n\t\t\t\t\t\t\"max_ecmp\": max_ecmp\n\t\t\t\t\t\t}\n\n\t\tspine_bgp_config = Template(\"\"\"\nrouter bgp $asn\n   router-id $routerid\n   maximum-paths $max_ecmp ecmp $max_ecmp\n   neighbor leafs peer group\n   neighbor leafs maximum-routes $max_routes \n   redistribute connected\"\"\").safe_substitute(Replacements)\n\n\t\tfor interface in spine_switch['interfaces']:\n\t\t\tReplacements = {\n\t\t\t\t\t\t\t\"neighbor\": interface['neighbor_ip'],\n\t\t\t\t\t\t\t\"asn\": interface['asn']\n\t\t\t\t\t\t\t}\n\t\t\tadd_to_sping_bgp_config = Template(\"\"\"\n   neighbor $neighbor peer group leafs\n   neighbor $neighbor remote-as $asn\"\"\").safe_substitute(Replacements)\n\t\t\tspine_bgp_config = spine_bgp_config + add_to_sping_bgp_config\n#\n# Create config unique for spine in evpn deployment type\n#\n\n\tif deploymenttype == \"evpn\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"routerid\": spine_switch['loopback'],\n\t\t\t\t\t\t\"linknet\": linknetwork,\n\t\t\t\t\t\t\"uplinks\": uplinks,\n\t\t\t\t\t\t\"asn\": spine_start_asn,\n\t\t\t\t\t\t\"max_routes\": max_routes,\n\t\t\t\t\t\t\"max_ecmp\": max_ecmp,\n\t\t\t\t\t\t\"max_evpn_routes\": max_evpn_routes\n\t\t\t\t\t\t}\n\n\t\tspine_bgp_config = Template(\"\"\"\nrouter bgp $asn\n   router-id $routerid\n   maximum-paths $max_ecmp ecmp $max_ecmp\n   neighbor leafs peer group\n   neighbor leafs maximum-routes $max_routes \n   neighbor EVPN peer group\n   neighbor EVPN bfd\n   neighbor EVPN maximum-routes $max_evpn_routes\n   neighbor EVPN next-hop-unchanged\n   neighbor EVPN update-source Loopback0\n   neighbor EVPN ebgp-multihop 4\n   neighbor EVPN send-community\n   redistribute connected\"\"\").safe_substitute(Replacements)\n\n\t\tfor interface in spine_switch['interfaces']:\n\t\t\tReplacements = {\n\t\t\t\t\t\t\t\"neighbor\": interface['neighbor_ip'],\n\t\t\t\t\t\t\t\"asn\": interface['asn']\n\t\t\t\t\t\t\t}\n\t\t\tadd_to_sping_bgp_config = Template(\"\"\"\n   neighbor $neighbor peer group leafs\n   neighbor $neighbor remote-as $asn\"\"\").safe_substitute(Replacements)\n\t\t\tspine_bgp_config = spine_bgp_config + add_to_sping_bgp_config\n\n\t\tfor leaf in Leafs:\n\t\t\tReplacements = {\n\t\t\t\t\t\t\t\"neighbor\": leaf['loopback'],\n\t\t\t\t\t\t\t\"asn\": leaf['asn']\n\t\t\t\t\t\t\t}\n\t\t\tadd_to_sping_bgp_config = Template(\"\"\"\n   neighbor $neighbor peer group EVPN\n   neighbor $neighbor remote-as $asn\"\"\").safe_substitute(Replacements)\n\t\t\tspine_bgp_config = spine_bgp_config + add_to_sping_bgp_config\n\n\t\tadd_to_sping_bgp_config = (\"\"\"\n   address-family evpn\"\"\")\n\t\tspine_bgp_config = spine_bgp_config + add_to_sping_bgp_config\n\n\t\tfor leaf in Leafs:\n\t\t\tReplacements = {\n\t\t\t\t\t\t\t\"neighbor\": leaf['loopback'],\n\t\t\t\t\t\t\t\"asn\": leaf['asn']\n\t\t\t\t\t\t\t}\n\t\t\tadd_to_sping_bgp_config = Template(\"\"\"\n      neighbor $neighbor activate\"\"\").safe_substitute(Replacements)\n\t\t\tspine_bgp_config = spine_bgp_config + add_to_sping_bgp_config\n\n\t\tadd_to_sping_bgp_config = (\"\"\"\n   address-family ipv4\"\"\")\n\t\tspine_bgp_config = spine_bgp_config + add_to_sping_bgp_config\n\n\t\tfor leaf in Leafs:\n\t\t\tReplacements = {\n\t\t\t\t\t\t\t\"neighbor\": leaf['loopback'],\n\t\t\t\t\t\t\t\"asn\": leaf['asn']\n\t\t\t\t\t\t\t}\n\t\t\tadd_to_sping_bgp_config = Template(\"\"\"\n      no neighbor $neighbor activate\"\"\").safe_substitute(Replacements)\n\t\t\tspine_bgp_config = spine_bgp_config + add_to_sping_bgp_config\n\n\tspine_bgp_configlet_name = spine_switch['name'] + \" BGP configuration\"\n\tif rebuild == 1:\n\t\tupdateMyConfiglet( server , spine_bgp_configlet_name , spine_bgp_config )\n\telse:\n\t\tspine_bgp_configlet = cvp.Configlet( spine_bgp_configlet_name , spine_bgp_config )\n\t\tserver.addConfiglet( spine_bgp_configlet )\n#\n# Build standalone shared configlets for CVX use case\n#\n\nif deploymenttype == \"cvx\":\n  Replacements = {\n\t  \"cvxserver\": cvxserver\n\t\t  }\n\n  cvx_config = Template(\"\"\"\n!\nmanagement cvx\n   no shutdown\n   server host $cvxserver\n!\n\"\"\").safe_substitute(Replacements)\n\n  cvx_configlet_name = name + \" CVX client configuration\"\n  cvx_configlet = cvp.Configlet( cvx_configlet_name, cvx_config )\n  if configletExists( server , cvx_configlet_name ):\n    updateMyConfiglet( server , cvx_configlet_name , cvx_config )\n  else:\n    server.addConfiglet( cvx_configlet )\n    cvx_configlet_list.append( cvx_configlet )\n\n#\n# Create Vxlan1 configlets based on CVX deployment type.\n#\n\nif deploymenttype == \"cvx\":\n\tReplacements = { \"dummy\": \"dummy\"\n\t\t\t\t\t}\n\tvxlan_leaf_config = Template(\"\"\"\ninterface Vxlan1\n   vxlan source-interface Loopback1\n   vxlan udp-port 4789\n   vxlan controller-client\n!\n\"\"\").safe_substitute(Replacements)\n\n#\n# Create Vxlan1 config based on HER deployment type.\n#\n\nif deploymenttype == \"her\":\n\tReplacements = { \"dummy\": \"dummy\",\n\t\t\t\t\t \"vteplist\": vteplist\n\t\t\t\t\t}\n\tvxlan_leaf_config = Template(\"\"\"\ninterface Vxlan1\n   vxlan source-interface Loopback1\n   vxlan udp-port 4789\n   vxlan flood vtep$vteplist\n!\n\"\"\").safe_substitute(Replacements)\n\n#\n# Create Vxlan1 config based on EVPN deployment type.\n#\n\nif deploymenttype == \"evpn\":\n\tReplacements = { \"dummy\": \"dummy\"\n\t\t\t\t\t}\n\tvxlan_leaf_config = Template(\"\"\"\ninterface Vxlan1\n   vxlan source-interface Loopback1\n   vxlan udp-port 4789\n!\n\"\"\").safe_substitute(Replacements)\n\n#\n# Create and add the VXLAN configlet, or update if it exists\n#\n\nvxlan_configlet_name = name + \" Interface VXLAN1 base configuration\"\nif rebuild == 1:\n\tupdateMyConfiglet ( server , vxlan_configlet_name , vxlan_leaf_config )\nelse:\n\tvxlan_configlet = cvp.Configlet( vxlan_configlet_name, vxlan_leaf_config )\n\tserver.addConfiglet( vxlan_configlet )\n\t\n# Build base config configlets for leafs and add them to CVP.\n# Start with config that is the same in all deployment types.\n#\n\nfor leaf in Leafs:\n\tif deploymenttype == \"her\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"hostname\": leaf['name'],\n\t\t\t\t\t\t\"loopback\": leaf['loopback'],\n\t\t\t\t\t\t\"vxlan\": leaf['vxlan'],\n\t\t\t\t\t\t\"mgmtip\": leaf['mgmt'],\n\t\t\t\t\t\t\"mgmtnetmask\": mgmtnetmask,\n\t\t\t\t\t\t\"mgmtvrf\": mgmtvrf\n\t\t\t\t\t\t}\n\t\tleaf_config = Template(\"\"\"\n!\nhostname $hostname\n!\ninterface Loopback0\n   ip address $loopback\/32\n!\ninterface Loopback1\n   ip address $vxlan\/32\n!\ninterface Management1\n   vrf $mgmtvrf\n   ip address $mgmtip\/$mgmtnetmask\n!\n\"\"\").safe_substitute(Replacements)\n\n\tif deploymenttype == \"cvx\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"hostname\": leaf['name'],\n\t\t\t\t\t\t\"loopback\": leaf['loopback'],\n\t\t\t\t\t\t\"vxlan\": leaf['vxlan'],\n\t\t\t\t\t\t\"mgmtip\": leaf['mgmt'],\n\t\t\t\t\t\t\"mgmtnetmask\": mgmtnetmask,\n\t\t\t\t\t\t\"mgmtvrf\": mgmtvrf\n\t\t\t\t\t\t}\n\t\tleaf_config = Template(\"\"\"\n!\nhostname $hostname\n!\ninterface Loopback0\n   ip address $loopback\/32\n!\ninterface Loopback1\n   ip address $vxlan\/32\n!\ninterface Management1\n   vrf $mgmtvrf\n   ip address $mgmtip\/$mgmtnetmask\n!\n\"\"\").safe_substitute(Replacements)\n\n\n\tif deploymenttype == \"evpn\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"hostname\": leaf['name'],\n\t\t\t\t\t\t\"loopback\": leaf['loopback'],\n\t\t\t\t\t\t\"mgmtip\": leaf['mgmt'],\n\t\t\t\t\t\t\"mgmtnetmask\": mgmtnetmask,\n\t\t\t\t\t\t\"mgmtvrf\": mgmtvrf,\n\t\t\t\t\t\t\"vxlan\": leaf['vxlan']\n\t\t\t\t\t\t}\n\t\tleaf_config = Template(\"\"\"\n!\nhostname $hostname\n!\ninterface Loopback0\n   ip address $loopback\/32\n!\ninterface Loopback1\n   ip address $vxlan\/32\n!\ninterface Management1\n   vrf $mgmtvrf\n   ip address $mgmtip\/$mgmtnetmask\n!\n\"\"\").safe_substitute(Replacements)\t\t\n\n#\n# Create MLAG config when leafs are organised as MLAG pairs.\n#\n\n\tif mlag == \"yes\":\n\t\tmlagtrunkinterfacelist = mlagtrunkinterfaces.split(',')\n\t\tmlagtrunkinterface1 = mlagtrunkinterfacelist[0]\n\t\tmlagtrunkinterface2 = mlagtrunkinterfacelist[1]\n\t\tReplacements = { \"mlaginterface\": leaf['mlaginterface'],\n\t\t\t\t\t\t \"mlagpeer\": leaf['mlagpeer'],\n\t\t\t\t\t\t \"mlagtrunkinterface1\": mlagtrunkinterface1,\n\t\t\t\t\t\t \"mlagtrunkinterface2\": mlagtrunkinterface2\n\t\t\t\t\t\t}\n\t\tmlag_add_to_leaf_config = Template(\"\"\"\n!\nvlan 4094\n   name MLAGPEER\n   trunk group mlagpeer\n!\nno spanning-tree vlan-id 4094\n!\ninterface port-channel 2000\n   switchport trunk group mlagpeer\n   switchport mode trunk\n!\ninterface $mlagtrunkinterface1\n   channel-group 2000 mode active\n!\ninterface $mlagtrunkinterface2\n   channel-group 2000 mode active\n!\ninterface Vlan4094\n   ip address $mlaginterface\/31\n!\nmlag\n   local-interface vlan 4094\n   peer-address $mlagpeer\n   peer-link port-channel 2000\n   domain-id MLAG\n!\n\"\"\").safe_substitute(Replacements)\n\t\tleaf_config = leaf_config + mlag_add_to_leaf_config\n\n#\n# Create BGP configlets for CVX and HER deployment types.\n# I.e. underlay BGP configlets.\n#\n\n\tif (deploymenttype == \"her\" or deploymenttype == \"cvx\") and mlag == \"no\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"routerid\": leaf['loopback'],\n\t\t\t\t\t\t\"uplinks\": uplinks,\n\t\t\t\t\t\t\"asn\": leaf['asn'],\n\t\t\t\t\t\t\"spine_asn\": spine_start_asn,\n\t\t\t\t\t\t\"max_ecmp\": max_ecmp,\n\t\t\t\t\t\t\"max_routes\": max_routes\n\t\t\t\t\t\t}\n\t\tleaf_bgp_config = Template(\"\"\"\nrouter bgp $asn\n   router-id $routerid\n   maximum-paths $max_ecmp ecmp $max_ecmp\n   neighbor spines peer group\n   neighbor spines remote-as $spine_asn\n   neighbor spines maximum-routes $max_routes\n   redistribute connected\"\"\").safe_substitute(Replacements)\n\n\tif (deploymenttype == \"her\" or deploymenttype == \"cvx\") and mlag == \"yes\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"routerid\": leaf['loopback'],\n\t\t\t\t\t\t\"mlagpeer\": leaf['mlagpeer'],\n\t\t\t\t\t\t\"uplinks\": uplinks,\n\t\t\t\t\t\t\"asn\": leaf['asn'],\n\t\t\t\t\t\t\"spine_asn\": spine_start_asn,\n\t\t\t\t\t\t\"max_ecmp\": max_ecmp,\n\t\t\t\t\t\t\"max_routes\": max_routes\n\t\t\t\t\t\t}\n\t\tleaf_bgp_config = Template(\"\"\"\nrouter bgp $asn\n   router-id $routerid\n   maximum-paths $max_ecmp ecmp $max_ecmp\n   neighbor spines peer group\n   neighbor spines remote-as $spine_asn\n   neighbor spines maximum-routes $max_routes\n   neighbor mlag-neighbor peer group\n   neighbor mlag-neighbor remote-as $asn\n   neighbor mlag-neighbor update-source vlan4094\n   neighbor $mlagpeer peer group mlag-neighbor\n   redistribute connected\"\"\").safe_substitute(Replacements)\n\n#\n# Create BGP configlets for EVPN deployment types.\n# I.e. underlay and EVPN overlay BGP configlets.\n#\n\n\tif deploymenttype ==  \"evpn\" and mlag == \"no\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"asn\": leaf['asn'] ,\n\t\t\t\t\t\t\"routerid\": leaf['loopback'],\n\t\t\t\t\t\t\"uplinks\": uplinks,\n\t\t\t\t\t\t\"spine_asn\": spine_start_asn,\n\t\t\t\t\t\t\"max_ecmp\": max_ecmp,\n\t\t\t\t\t\t\"max_routes\": max_routes,\n\t\t\t\t\t\t\"max_evpn_routes\": max_evpn_routes\n\t\t\t\t\t\t}\n\t\tleaf_bgp_config = Template(\"\"\"\nrouter bgp $asn\n   router-id $routerid\n   maximum-paths $max_ecmp ecmp $max_ecmp\n   neighbor EVPN peer group\n   neighbor EVPN update-source Loopback0\n   neighbor EVPN ebgp-multihop 4\n   neighbor EVPN send-community\n   neighbor EVPN bfd\n   neighbor EVPN maximum-routes $max_evpn_routes\n   neighbor spines peer group\n   neighbor spines remote-as $spine_asn\n   neighbor spines maximum-routes $max_routes\"\"\").safe_substitute(Replacements)\n\n\tif deploymenttype ==  \"evpn\" and mlag == \"yes\":\n\t\tReplacements = {\n\t\t\t\t\t\t\"asn\": leaf['asn'] ,\n\t\t\t\t\t\t\"routerid\": leaf['loopback'],\n\t\t\t\t\t\t\"mlagpeer\": leaf['mlagpeer'],\n\t\t\t\t\t\t\"uplinks\": uplinks,\n\t\t\t\t\t\t\"spine_asn\": spine_start_asn,\n\t\t\t\t\t\t\"max_ecmp\": max_ecmp,\n\t\t\t\t\t\t\"max_routes\": max_routes,\n\t\t\t\t\t\t\"max_evpn_routes\": max_evpn_routes\n\t\t\t\t\t\t}\n\t\tleaf_bgp_config = Template(\"\"\"\nrouter bgp $asn\n   router-id $routerid\n   maximum-paths $max_ecmp ecmp $max_ecmp\n   neighbor EVPN peer group\n   neighbor EVPN update-source Loopback0\n   neighbor EVPN ebgp-multihop 4\n   neighbor EVPN send-community\n   neighbor EVPN bfd\n   neighbor EVPN maximum-routes $max_evpn_routes\n   neighbor mlag-neighbor peer group\n   neighbor mlag-neighbor remote-as $asn\n   neighbor mlag-neighbor update-source vlan4094\n   neighbor $mlagpeer peer group mlag-neighbor\n   neighbor spines peer group\n   neighbor spines remote-as $spine_asn\n   neighbor spines maximum-routes $max_routes\"\"\").safe_substitute(Replacements)\n\n#\n# Build interface configlets for each leaf. Add BGP neighbor configuration to\n# BGP configlets.\n#\n\n\tfor spine_switch in DC:\n\t\tfor interface in spine_switch['interfaces']:\n\t\t\tif interface['neighbor'] == leaf['name']:\n\t\t\t\tReplacements = {\n\t\t\t\t\t\t\t\t\"interface\": interface['neighbor_interface'],\n\t\t\t\t\t\t\t\t\"description\": spine_switch['name'],\n\t\t\t\t\t\t\t\t\"neighbor_ip\": interface['neighbor_ip']\n\t\t\t\t\t\t\t\t}\n\t\t\t\tadd_to_leaf_config = Template(\"\"\"\n!\ninterface $interface\n   description $description\n   no switchport\n   ip address $neighbor_ip\/31\n!\n\"\"\").safe_substitute(Replacements)\n\t\t\t\tleaf_config = leaf_config + add_to_leaf_config\n\n\t\t\t\tif deploymenttype == \"her\" or deploymenttype == \"cvx\":\n\t\t\t\t\tReplacements = {\n\t\t\t\t\t\t\t\t\t\"neighborip\": linknetwork + str(int(interface['neighbor_int']) -1)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\tadd_to_leaf_bgp_config = Template(\"\"\"\n   neighbor $neighborip peer group spines\"\"\").safe_substitute(Replacements)\n\t\t\t\t\tleaf_bgp_config = leaf_bgp_config + add_to_leaf_bgp_config\n\n\t\t\t\tif deploymenttype == \"evpn\":\n\t\t\t\t\tReplacements = {\n\t\t\t\t\t\t\t\t\t\"neighborip\": linknetwork + str(int(interface['neighbor_int']) -1)\n\t\t\t\t\t}\n\t\t\t\t\tadd_to_leaf_bgp_config = Template(\"\"\"\n   neighbor $neighborip peer group spines\"\"\").safe_substitute(Replacements)\n\t\t\t\t\tleaf_bgp_config = leaf_bgp_config + add_to_leaf_bgp_config\n\t\t\t\t\t\n\tif deploymenttype == \"evpn\":\n\t\tfor evpnleaf in DC:\n\t\t\tReplacements = {\n\t\t\t\t\t\t\t\"loopback\": evpnleaf['loopback'],\n\t\t\t\t\t\t\t\"asn\": spine_start_asn\n\t\t\t\t\t\t\t}\n\t\t\tadd_to_leaf_bgp_config = Template(\"\"\"\n   neighbor $loopback peer group EVPN\n   neighbor $loopback remote-as $asn\"\"\").safe_substitute(Replacements)\n\t\t\tleaf_bgp_config = leaf_bgp_config + add_to_leaf_bgp_config\n\n\tif deploymenttype == \"evpn\":\n\t\n\t\tadd_to_leaf_bgp_config = \"\"\"\n   address-family evpn\"\"\"\n\t\tleaf_bgp_config = leaf_bgp_config + add_to_leaf_bgp_config\n\n\tif deploymenttype == \"evpn\":\n\t\tfor evpnleaf in DC:\n\t\t\tReplacements = {\n\t\t\t\t\t\t\t\"loopback\": evpnleaf['loopback'],\n\t\t\t\t\t\t\t\"asn\": spine_start_asn\n\t\t\t\t\t\t\t}\n\t\t\tadd_to_leaf_bgp_config = Template(\"\"\"\n      neighbor $loopback activate\"\"\").safe_substitute(Replacements)\n\t\t\tleaf_bgp_config = leaf_bgp_config + add_to_leaf_bgp_config\n\n\tif deploymenttype == \"evpn\":\n\t\tadd_to_leaf_bgp_config = \"\"\"\n   address-family ipv4\"\"\"\n\t\tleaf_bgp_config = leaf_bgp_config + add_to_leaf_bgp_config\n\t\tfor evpnleaf in DC:\n\t\t\tReplacements = {\n\t\t\t\t\t\t\t\"loopback\": evpnleaf['loopback'],\n\t\t\t\t\t\t\t\"asn\": spine_start_asn\n\t\t\t\t\t\t\t}\n\t\t\tadd_to_leaf_bgp_config = Template(\"\"\"\n      no neighbor $loopback activate\"\"\").safe_substitute(Replacements)\n\t\t\tleaf_bgp_config = leaf_bgp_config + add_to_leaf_bgp_config\n\n\tif deploymenttype == \"evpn\":\n\t\tadd_to_leaf_bgp_config = \"\"\"\n      redistribute connected\"\"\"\n\t\tleaf_bgp_config = leaf_bgp_config + add_to_leaf_bgp_config\n\n#\n# If debug is activated, only print config that should have gone into configlets,\n# do not actually create configlets. If debug is not activated, create configlets\n# and add them to CVP.\n#\n\n\tleaf_configlet_name = leaf['name'] + \" configuration\"\n\tif rebuild == 1:\n\t\tupdateMyConfiglet ( server , leaf_configlet_name , leaf_config )\n\telse:\n\t\tleaf_configlet = cvp.Configlet( leaf_configlet_name , leaf_config )\n\t\tserver.addConfiglet( leaf_configlet )\n\t\t\n\tleaf_bgp_configlet_name = leaf['name'] + \" bgp configuration\"\n\tif rebuild == 1:\n\t\tupdateMyConfiglet ( server , leaf_bgp_configlet_name , leaf_bgp_config )\n\telse:\n\t\tleaf_bgp_configlet = cvp.Configlet( leaf_bgp_configlet_name , leaf_bgp_config )\n\t\tserver.addConfiglet( leaf_bgp_configlet )\n\t\t\n\n\n\n\n\n#\n# If debug is not activated, create Container structure for new DC\n#\n\nif rebuild == 0:\n\tmy_dc_container = cvp.Container( name, parentName )\n\tserver.addContainer( my_dc_container )\n\tserver.mapConfigletToContainer( my_dc_container , configlet_list )\n\tif deploymenttype == \"cvx\":\n\t  server.mapConfigletToContainer( my_dc_container , cvx_configlet_list )\n\n\tmy_leaf_container = cvp.Container( my_leaf_container_name , name )\n\tserver.addContainer( my_leaf_container )\n\tleaf_configlet_list.append( vxlan_configlet )\n\tserver.mapConfigletToContainer( my_leaf_container , leaf_configlet_list )\n\n\tmy_spine_container = cvp.Container( my_spine_container_name , name )\n\tserver.addContainer( my_spine_container )\n","key":"mainscript_1597857505429"}}]}}